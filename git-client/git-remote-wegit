#!/usr/bin/env node

// Imports
// =============================================================================

const net = require('net');
const cp = require('child_process');

// Main
// =============================================================================

/*
    const gitProcess = cp.spawn('git', [
      'hash-object',
      '-t',
      payload.type,
      '-w',
      '--stdin',
    ]);*/

//const MAX_SIZE = 10000;

const onFetchResponse = ({ value, type }) => {
  if (type !== 'pack') throw new Error('Not implemented');

  const gitProcess = cp.spawn('git', [
    'index-pack',
    '--stdin',
    '-v',
    '--fix-thin',
  ]);

  gitProcess.on('exit', code => {
    console.warn('[4]');

    console.warn({ code });
    process.stdout.write('\n');
  });

  gitProcess.stdin.write(Buffer.from(Uint8Array.from(value).buffer), () => {
    console.warn('[3]');

    gitProcess.stdin.end();
  });
};

const createRef = async ({ sha, ref }) =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['update-ref', ref, sha]);

    gitProcess.on('exit', () => resolve());
  });

let inRef;
let outRef;
let chunks = {};

const receiveChunk = (
  connection,
  { id, type, chunk, chunkNo, chunksCount, ...messageData },
) => {
  if (!chunks[id]) {
    chunks[id] = '';
  }
  chunks[id] = chunks[id] + chunk;
  if (chunkNo !== chunksCount - 1) {
    connection.write(
      JSON.stringify({
        type: 'app:nextChunk',
        payload: { id },
      }),
    );
  } else {
    const message = {
      ...messageData,
      id,
      type,
      payload: JSON.parse(chunks[id]),
    };
    onMessageFromWeGit(connection)(message);
    delete chunks[id];
  }
};

const onMessageFromWeGit = connection => async ({ type, payload }) => {
  if (type === 'app:chunks') {
    receiveChunk(connection, payload);
  } else if (type === 'app:transport:capabilitiesResponse') {
    process.stdout.write(payload.value.join('\n') + '\n\n');
  } else if (type === 'app:transport:listResponse') {
    await Promise.all(
      payload.value.map(({ sha, ref }) => createRef({ sha, ref })),
    );
    const output =
      payload.value.map(({ sha, ref }) => `${sha} ${ref}`).join('\n') + '\n\n';

    process.stdout.write(output);
  } else if (type === 'app:transport:listForPushResponse') {
    const gitProcess = cp.spawn('git', ['show-ref', '--head']);
    gitProcess.stdout.on('readable', () => {
      const value = gitProcess.stdout.read();
      if (!value) return;
      outRef = payload.value;
      inRef = value
        .toString()
        .trim()
        .split('\n')
        .map(l => {
          const [sha, ref] = l.split(' ');
          return { sha, ref };
        });

      const output =
        payload.value.map(({ sha, ref }) => `${sha} ${ref}`).join('\n') +
        '\n\n';
      process.stdout.write(output);
    });
  } else if (type === 'app:transport:fetchResponse') {
    onFetchResponse(payload);
  }
};

const main = async () => {
  const connection = net.connect({ port: 9001 }, () => {
    connection.on('data', message => {
      const parsedMessage = JSON.parse(message.toString());
      console.warn('IN', JSON.stringify(parsedMessage).slice(0, 200), '\n');
      onMessageFromWeGit(connection)(parsedMessage);
    });

    process.stdin.setEncoding('utf8');

    process.stdin.on('readable', () => {
      const value = process.stdin.read();
      console.warn('OUT', value);
      switch (value) {
        case null:
          process.exit();
          break;
        case 'capabilities\n':
          connection.write(
            JSON.stringify({
              type: 'app:transport:capabilities',
            }),
          );
          break;
        case 'list\n':
          connection.write(
            JSON.stringify({
              type: 'app:transport:list',
            }),
          );
          break;
        case 'list for-push\n':
          connection.write(
            JSON.stringify({
              type: 'app:transport:listForPush',
            }),
          );
          break;

        default:
      }

      if (value.startsWith('fetch')) {
        const [_, sha, ref] = value.trim().split(' ');

        connection.write(
          JSON.stringify({
            type: 'app:transport:fetch',
            payload: {
              sha,
              ref,
            },
          }),
        );
      } else if (value.startsWith('push')) {
        const [srcRef, distRef] = value
          .trim()
          .split(' ')[1]
          .split(':');
        console.warn(value, { srcRef, distRef });
      }
    });
  });

  connection.on('end', () => {
    console.warn('disconnected from server');
  });
};

main();
