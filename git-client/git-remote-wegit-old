#!/usr/bin/env node

// Imports
// =============================================================================

const net = require('net');
const cp = require('child_process');
const uuid = require('uuid/v4');

// Main
// =============================================================================

/*
    const gitProcess = cp.spawn('git', [
      'hash-object',
      '-t',
      payload.type,
      '-w',
      '--stdin',
    ]);*/

const MAX_SIZE = 100;

const sentInChunksGenerators = {};

const sendAllInChunksGenerator = function*(connection, id, type, fullPayload) {
  const chunksCount = Math.ceil(fullPayload.length / MAX_SIZE);
  for (let i = 0; i < chunksCount; i++) {
    const chunk = fullPayload.slice(i * MAX_SIZE, (i + 1) * MAX_SIZE);

    connection.write(
      JSON.stringify({
        type: 'app:chunks',
        payload: {
          id,
          type: `app:${type}`,
          chunk,
          chunkNo: i,
          chunksCount,
        },
      }),
    );

    yield;
  }
};

const sendInChunks = (connection, type, fullPayload) => {
  const id = uuid();
  sentInChunksGenerators[id] = sendAllInChunksGenerator(
    connection,
    id,
    type,
    fullPayload,
  );
  sentInChunksGenerators[id].next();
};

const sendMessage = (connection, message) => {
  const { type, payload } = message;

  const fullPayload = payload && JSON.stringify(payload);
  if (fullPayload && fullPayload.length > MAX_SIZE)
    sendInChunks(connection, type, fullPayload);
  else
    connection.write(
      JSON.stringify({
        type: `app:${type}`,
        payload,
      }),
    );
};

const onFetchResponse = ({ value, type }) => {
  if (type !== 'pack') throw new Error('Not implemented');

  const gitProcess = cp.spawn('git', [
    'index-pack',
    '--stdin',
    '-v',
    '--fix-thin',
  ]);

  gitProcess.on('exit', () => {
    process.stdout.write('\n');
  });

  gitProcess.stdin.write(Buffer.from(Uint8Array.from(value).buffer), () => {
    gitProcess.stdin.end();
  });
};

const createRef = async ({ sha, ref }) =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['update-ref', ref, sha]);

    gitProcess.on('exit', () => resolve());
  });

let chunks = {};

const receiveChunk = (
  connection,
  { id, type, chunk, chunkNo, chunksCount, ...messageData },
) => {
  if (!chunks[id]) {
    chunks[id] = '';
  }
  chunks[id] = chunks[id] + chunk;
  if (chunkNo !== chunksCount - 1) {
    sendMessage(connection, {
      type: 'nextChunk',
      payload: { id },
    });
  } else {
    const message = {
      ...messageData,
      id,
      type,
      payload: JSON.parse(chunks[id]),
    };
    onMessageFromWeGit(connection)(message);
    delete chunks[id];
  }
};

const commitsBetween = async (fromSha, toSha) =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', [
      'rev-list',
      '--ancestry-path',
      `${fromSha}..${toSha}`,
    ]);

    gitProcess.stdout.on('readable', async () => {
      const value = gitProcess.stdout.read();
      if (!value) return;
      resolve(
        value
          .toString()
          .trim()
          .split('\n'),
      );
    });
  });

const getGitObject = async (sha, type) =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['cat-file', '-p', sha]);

    gitProcess.stdout.on('readable', async () => {
      const value = gitProcess.stdout.read();
      if (!value) return;
      const lines = value
        .toString()
        .trim()
        .split('\n');
      if (type === 'commit') {
        resolve({
          type,
          tree: lines[0].replace('tree ', ''),
          parent: lines[1].replace('parent ', ''),
        });
      } else if (type === 'tree') {
        resolve({
          type,
          gitObjects: lines.map(row => {
            const [mode, type, sha, path] = row.split(/\t| /);
            return { mode, type, sha, path };
          }),
        });
      }
    });
  });

const getTreeAllNestedShas = async treeSha => {
  const treeGitObject = await getGitObject(treeSha, 'tree');
  const treeShas = treeGitObject.gitObjects
    .filter(o => o.type === 'tree')
    .map(o => o.sha);
  const treeNestedShas = (await Promise.all(
    treeShas.map(getTreeAllNestedShas),
  )).flat();

  const otherShas = treeGitObject.gitObjects
    .filter(o => o.type !== 'tree')
    .map(o => o.sha);

  return [...treeShas, ...treeNestedShas, ...otherShas];
};

const getCommitAllNestedShas = async commitSha => {
  const commit = await getGitObject(commitSha, 'commit');
  const treeShas = await getTreeAllNestedShas(commit.tree);
  return [commit.tree, ...treeShas];
};

const gitObjectShasBetween = async (fromSha, toSha) => {
  const commitsDiff = await commitsBetween(fromSha, toSha);

  const allShas = (await Promise.all(
    commitsDiff.map(c => getCommitAllNestedShas(c)),
  )).flat();

  const uniqueShas = Array.from(new Set(allShas));
  const initialShas = await getCommitAllNestedShas(fromSha);
  return [...uniqueShas.filter(s => !initialShas.includes(s)), ...commitsDiff];
};

let srcRefObjects;
let distRefObjects;

const readObjectType = async sha =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['cat-file', '-t', sha]);

    gitProcess.stdout.on('readable', async () => {
      const line = gitProcess.stdout.read();
      if (!line) return;
      resolve(line.toString().trim());
    });
  });

const readObjectContents = async sha =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['cat-file', '-p', sha]);

    gitProcess.stdout.on('readable', async () => {
      const contents = gitProcess.stdout.read();
      if (!contents) return;
      resolve(Array.from(contents));
    });
  });

const readObject = async sha => {
  const type = await readObjectType(sha);
  const contents = await readObjectContents(sha);
  return { type, contents };
};

const pushCommits = async (connection, srcRef, distRef) => {
  const srcSha = srcRefObjects.find(o => o.ref === srcRef).sha;
  const distSha = distRefObjects.find(o => o.ref === distRef).sha;

  // NOTE: src & dist is the opposite here, which is confusing
  const shas = await gitObjectShasBetween(distSha, srcSha);
  // NOTE: should be sending packed objects, fttb read and send all objects
  // unpacked
  const objects = await Promise.all(shas.map(readObject));
  sendMessage(connection, {
    type: 'transport:push',
    payload: {
      beforeRefObject: { ref: distRef, sha: distSha },
      afterRefObject: { ref: srcRef, sha: srcSha },
      objects,
    },
  });
  /*const gitProcess = cp.spawn('git', ['pack-objects', '--stdout']);

  gitProcess.stdin.write(shas.join('\n'), () => {
    gitProcess.stdin.end();
  });

  gitProcess.stdout.on('readable', async () => {
    const pack = gitProcess.stdout.read();
    if (!pack) return;
    sendMessage(connection, {
      type: 'transport:push',
      payload: {
        distRefObject: { ref: srcRef, sha: srcSha },
        srcRefObject: { ref: distRef, sha: distSha },
        pack: Array.from(pack),
      },
    });
  });*/
};

const onMessageFromWeGit = connection => async ({ type, payload }) => {
  if (type === 'app:chunks') {
    receiveChunk(connection, payload);
  } else if (type === 'app:nextChunk') {
    const { id } = payload;
    const { done } = sentInChunksGenerators[id].next();
    if (done) delete sentInChunksGenerators[id];
  } else if (type === 'app:transport:capabilitiesResponse') {
    process.stdout.write(payload.value.join('\n') + '\n\n');
  } else if (type === 'app:transport:listResponse') {
    const output =
      payload.value.map(({ sha, ref }) => `${sha} ${ref}`).join('\n') + '\n\n';

    process.stdout.write(output);
  } else if (type === 'app:transport:listForPushResponse') {
    const gitProcess = cp.spawn('git', ['show-ref', '--head']);
    gitProcess.stdout.on('readable', () => {
      const value = gitProcess.stdout.read();
      if (!value) return;
      distRefObjects = payload.value;
      srcRefObjects = value
        .toString()
        .trim()
        .split('\n')
        .map(l => {
          const [sha, ref] = l.split(' ');
          return { sha, ref };
        });
      const output =
        payload.value.map(({ sha, ref }) => `${sha} ${ref}`).join('\n') +
        '\n\n';
      process.stdout.write(output);
    });
  } else if (type === 'app:transport:fetchResponse') {
    onFetchResponse(payload);
  } else if (type === 'app:transport:pushResponse') {
    const output = `ok ${payload.value.beforeRefObject.ref}\n\n`;
    process.stdout.write(output);
  }
};

const main = async () => {
  const connection = net.connect({ port: 9001 }, () => {
    connection.on('data', message => {
      const parsedMessage = JSON.parse(message.toString());
      console.warn('IN', JSON.stringify(parsedMessage).slice(0, 200), '\n');
      onMessageFromWeGit(connection)(parsedMessage);
    });

    process.stdin.setEncoding('utf8');

    process.stdin.on('readable', async () => {
      const value = process.stdin.read();
      console.warn('OUT', value);
      switch (value) {
        case null:
          process.exit();
          break;
        case 'capabilities\n':
          sendMessage(connection, {
            type: 'transport:capabilities',
          });
          break;
        case 'list\n':
          sendMessage(connection, {
            type: 'transport:list',
          });
          break;
        case 'list for-push\n':
          sendMessage(connection, {
            type: 'transport:listForPush',
          });
          break;

        default:
      }

      if (value.startsWith('fetch')) {
        const refs = value
          .trim()
          .replace(/fetch /g, '')
          .split('\n')
          .map(line => {
            const [sha, ref] = line.split(' ');
            return { sha, ref };
          });

        await Promise.all(refs.map(({ sha, ref }) => createRef({ sha, ref })));

        sendMessage(connection, {
          type: 'transport:fetch',
          payload: { value: refs },
        });
      } else if (value.startsWith('push')) {
        const [srcRef, distRef] = value
          .trim()
          .split(' ')[1]
          .split(':');
        pushCommits(connection, srcRef, distRef);
      }
    });
  });

  connection.on('end', () => {
    console.warn('disconnected from server');
  });
};

main();
