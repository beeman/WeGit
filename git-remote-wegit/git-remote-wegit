#!/usr/bin/env node

// Imports
// =============================================================================

const cp = require('child_process');
const fs = require('fs');
const net = require('net');

const git = require('isomorphic-git');
const gitInternals = require('isomorphic-git/dist/for-node/isomorphic-git/internal-apis');
const ora = require('ora');

const receiveInChunksMiddleware = require('wegit-lib/utils/receiveInChunksMiddleware');
const sendInChunksMiddleware = require('wegit-lib/utils/sendInChunksMiddleware');

const parser = require('./lib/parser');
const transportMiddleware = require('./lib/transportMiddleware');

// Utils
// =============================================================================
const onError = message => {
  console.warn('');
  console.warn(`Error: ${message}`);
  process.exit(1);
};

const findAgent = meshState => {
  const wgOsConnection = meshState.connections
    .filter(c => c.state === 'connected')
    .filter(c => c.user && c.user.type === 'browser')[0];
  if (!wgOsConnection) return;

  return wgOsConnection.user.id;
};

const getRootDir = async () =>
  new Promise(resolve => {
    const gitProcess = cp.spawn('git', ['rev-parse', '--git-dir']);
    gitProcess.stdout.on('readable', () => {
      const value = gitProcess.stdout.read();
      if (!value) return;

      resolve(
        value
          .toString()
          .trim()
          .replace(/\/\.git$/, ''),
      );
    });
  });

// Main
// =============================================================================

const DEBUG = false;

const port = process.env.PORT || 1996;

git.plugins.set('fs', fs);

const main = async () => {
  let meshState = {
    connections: [],
    globalState: 'disconnected',
  };

  const onChange = nextMeshState => (meshState = nextMeshState);

  const dir = await getRootDir();

  const connection = net.connect({ port }, () => {
    const remote = process.argv[2];
    const url = process.argv[3];

    const spinner = ora('Connecting…').start();
    const onProgress = progress => {
      const phase =
        progress.phasesTotal > 1
          ? `(${progress.phaseNo}/${progress.phasesTotal}) `
          : '';

      const loaded = progress.lengthComputable
        ? ` ${Math.floor((progress.loaded / progress.total) * 100)}%`
        : '';

      spinner.text = `${phase}${progress.phase}…${loaded}\n`;
    };

    const { send, onMessage } = receiveInChunksMiddleware(
      transportMiddleware({
        git,
        gitInternals,
        fs,
        dir,
        remote,
        url,
        onError,
        onProgress,
        DEBUG,
      })(
        sendInChunksMiddleware({
          send(userId, message) {
            if (!userId) return;
            const { type, payload } = message;
            connection.write(
              JSON.stringify({
                method: 'send',
                args: [userId, { type: `app:${type}`, payload }],
              }),
            );
          },

          onMessage(message) {
            const value = parser.messageToStdout(message);
            if (DEBUG) console.warn('[<-]', value);

            process.stdout.write(value);
          },
        }),
      ),
    );
    connection.on('data', data => {
      const { method, args } = JSON.parse(data.toString());
      switch (method) {
        case 'change':
          return onChange(...args);
        case 'send':
          return onMessage(...args, {
            onProgress: progress => {
              onProgress({
                ...progress,
                phaseNo: 2,
                phasesTotal: 2,
              });
            },
          });
        default:
          return onError(`unknown method ${method}`);
      }
    });

    process.stdin.setEncoding('utf8');
    process.stdin.on('readable', async () => {
      const value = process.stdin.read();

      if (value === null || value === '\n') {
        process.exit();
        return;
      }

      if (DEBUG) console.warn('[->]', value);
      const message = parser.stdinToMessage(value);
      send(findAgent(meshState), message);
    });
  });

  connection.on('end', () => onError('disconnected from server'));
};

main();
